<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Eternal Sunshine of the Biased Mind</title>
    <meta name="description" content="">
    <style>
      :root {
        --vert-deck-slide-margin: 50px auto;
      }
      body {
        font-family: Helvetica;
        margin: 0;
        padding: 0;
      }
      vert-deck {
        height: 100vh;
        width: 100vw;
      }
      vert-deck:not(:defined) {
        display: none;
      }
    </style>
  </head>
  <body>
    <vert-deck focused slide-markdown-css="h1 { text-align: center; }">
      <vert-slide>
        # The eternal sunshine of the biased mind

        <p style="text-align: center">https://treshugart.github.io/talks/esotbm</p>

        < Hi, I'm' Trey. I'm going to talk to you a little bit about bias. I'm definitely not an expert in the field, but I'm curious about psychology, and how it affects the choices and decisions people make in our industry.

        < If you want to check out some of the links or follow along, you can go to the URL shown here.

        < For the first part of this talk, I'm going to focus on some forms of cognitive bias and touch on how bias relates to our industry, and every day lives, which will help give context to the rest of the talk.
      </vert-slide>
      <vert-slide>
        # Bias

        [Bias](https://en.wikipedia.org/wiki/Bias) is an inclination to hold a partial perspective, often accompanied by a refusal to consider alternative points of view.

        A [Cognitive bias](https://en.wikipedia.org/wiki/Cognitive_bias) is a shortcut in thinking that can sometimes lead to errors in judgement.

        < To start off, let's define "bias".
        
        < *read definition of bias*

        < And more specifically...

        < *read definition of cognitive bias*
      </vert-slide>
      <vert-slide>
        # Bias

        <talk-img src="img/young-old-woman-illusion.jpg" alt="Old / young woman illusion"></talk-img>

        < A lot of you have probably see this illusion before. Depending on how you interpret it, you may see an old woman looking downward, or a young woman looking over her shoulder.

        < Bias is a funny thing because you could be looking at the same set of facts and see different things based on your perspective and past experiences.
      </vert-slide>
      <vert-slide>
        # Bias

        Helps with many forms of every day life:

        - Crossing the street
        - Skimming a blog post
        - What to eat for dinner

        < We see bias every day: at the grocery store, on TV and in politics. We definitely see it in politics.

        < Bias is what keeps us from getting run over when we cross the street. It fills in the blanks when we're skimming through a lengthy blog post and don't have time to read every sentence. It even gets us fed.
      </vert-slide>
      <vert-slide>
        # Bias

        But can also hinder:

        - Could get hit by an unseen car
        - Misinterpretting key points in a blog post
        - Mis-reading food expiry label

        < Though biases may offer shortcuts in making quick decisions, you may have made incorrect assumptions about key points in that blog post that was imperative in making a recent decision on your tech stack. You may have gotten food poisining because you mis-read the expiry date on the chicken wings you ate last night.

        < You will never be able to completely remove bias. There's no way you're going to be able to calculate, with 100% accuracy, that crossing the road is safe, though, you might come close. Even if there's no cars, you could trip on a rock in the middle of the road, get knocked out cold and a distracted driver could still run you over. It's unlikely, but still entirely possible.
      </vert-slide>
      <vert-slide>
        # Our bias

        We see it every day:

        - Tabs vs spaces
        - OOP vs FRP
        - Typescript vs Flow
        - Web Components vs ...
        - vs vs vs!

        <talk-img src="img/fight.png"></talk-img>

        < We also see it everyday in our industry.

        < *read out list and on the last one...*

        < It seems like everything is constantly at odds with each other. It's not always that way, but we love nothing more than to jump at an opportunity to have an opinion. Often, people listen to respond, rather than to learn.
      </vert-slide>
      <vert-slide>
        # Our bias

        > We argue because we feel so emotionally committed to our case, but there is no objectively right answer.

        > &mdash; [Sam Koblenski](http://sam-koblenski.blogspot.com.au/2015/04/programming-bias-comes-from-experience.html)

        < I was reading this article the other day written by a programmer named Sam Koblenski. A couple excerpts from early on in his post caught my eye.

        < *read quote*

        < Most, if not all of us, have argued for, or against something. Many of us do it with passion. I believe this statement to &mdash; unfortunately &mdash; be true for many arguments.
      </vert-slide>
      <vert-slide>
        # Our bias

        > We argue because we feel so emotionally committed to our case<strike>, but there is no objectively right answer</strike>.

        > &mdash; [Sam Koblenski](http://sam-koblenski.blogspot.com.au/2015/04/programming-bias-comes-from-experience.html)

        < However, if we can try to identify and mitigate our own bias, then we will be more effective in making objective decisions.
      </vert-slide>
      <vert-slide>
        # Our bias

        > That thing that the programmer grew to despise may not have been directly responsible for the failure, but it was there and it was noticed.

        > &mdash; [Sam Koblenski](http://sam-koblenski.blogspot.com.au/2015/04/programming-bias-comes-from-experience.html)

        - [Illusory correlation](https://en.wikipedia.org/wiki/Illusory_correlation) - when a relationship between two things is perceived, but doesn't actually exist.
        - [Halo effect](https://en.wikipedia.org/wiki/Bias#Halo_effect) - when a positive experience toward something predisposes you to think more positively about whatever it was you experienced.
        - [Belief perseverance](https://en.wikipedia.org/wiki/Confirmation_bias#Persistence_of_discredited_beliefs) - when beliefs persist even after facts are presented to counter them.
        - <a href="https://en.wikipedia.org/wiki/Conservatism_(belief_revision)">Conservitism</a> - when the effort to revise your beliefs based on fact is insufficient.

        < Another quote also caught my eye.

        < *read quote*

        < Our biases come from experience. Some baises are correctly linked and some may be the result of an indirect phenomenon called an [illusory correlation](https://en.wikipedia.org/wiki/Illusory_correlation), which is when a relationship between variables is perceived, but doesn't actually exist.

        < This quote describes a developer who had a negative experience with something. In a differenct scenario, they could have had a positive experience. Either way, that developer's predisposition to the subject matter is likely to end up being biased by their experience with it. For positive experiences this is called the halo effect, and for negatives, the reverse halo effect, devil effect or horns effect.

        < I'd venture to say the halo effect, and its counterpart, play a major part in how many of us perceive libraries and frameworks.

        < But what happens when you're presented with factual evidence to counter an experience? Your beliefs may persist. It could be for many reasons but the fact that this happens can be described by [belief perseverance](https://en.wikipedia.org/wiki/Confirmation_bias#Persistence_of_discredited_beliefs), or the continued influence effect. Even after a correction has been made, misinformation can continue to influence the inferences one generates.
        
        < Related to this is conservitism, or belief revision, meaning, the effort to revise your beliefs based on facts is insufficient and your previous beliefs continue to influence the choices you make and how you perceive information that is presented to you.
      </vert-slide>
      <vert-slide>
        # Bias blind spot

        [Bias blind spot](https://en.wikipedia.org/wiki/Bias_blind_spot)

        - Recognise bias in others
        - Failure to recognise your own
        - Potential for unproductive interactions
        - Help mitigate by recognising your own bias

        < In my opinion, probably one of the more imporant types of cognitive biases is the bias blind spot. It's the ability to recognise the bias of others, but fail to recognise your own.

        < I've always been interested in psychology and I did quite a bit of studying in preparation for this talk. It got me very excited and I found myself trying to call out biases in discussions and conversations and, while it's sort of obvious now, it wasn't' very productive. I was totally that guy.
        
        < In my experience, I've found that if I can recognise my own bias, I can make myself less subjective. I end up making better decisions while having more positive interactions with others. I've also found that objectivity can be contaigious, where others may become more objective if they see other people being objective. I've seen subjectivity have the inverse effect.
      </vert-slide>
      <vert-slide>
        # Confirmation bias

        [Confirmation bias](https://en.wikipedia.org/wiki/Confirmation_bias)

        When you search for information that supports your point of view.

        <talk-img src="img/xkcd-conspiracy-theories.png" height="500"></talk-img>

        < I'm just going to quickly go through some other types of bias before moving on.

        < Probably one of the more well-known types of cognitive biases is confirmation bias. For example, since I support web components, I am more likely to search for &mdash; and interpret &mdash; information about web components in a way that supports my pre-existing beliefs.
      </vert-slide>
      <vert-slide>
        # Bandwagon effect

        [Bandwagon effect](https://en.wikipedia.org/wiki/Bandwagon_effect)

        When the adoption rate of something increases the more attention it gets.

        <talk-img src="img/xkcd-bridge.png"></talk-img>

        < The bandwagon effect is when the adoption rate of something increases the more it is adopted by others. This is basically Github stars in a nutshell.
        
        < A friend of mine asked for my professional opinion on front-end stacks. I suggested he use Preact. Although this is indicative of other biases, too, he quickly dismissed it and chose React instead, due to popularity.
      </vert-slide>
      <vert-slide>
        # Choice-supportive bias

        [Choice-supportive bias](https://en.wikipedia.org/wiki/Choice-supportive_bias)

        Downplaying faults, or highlighting advantages, of past decisions.

        <talk-img src="img/xkcd-natural-parenting.png"></talk-img>

        < The choice supportive bias is an interesting one. When looking back on a choice, it's when you downplay the faults &mdash; or highlight the advantages &mdash; of the option you chose, while possibly doing the inverse for the option you didn't choose.
        
        < You might sometimes say, "well, look at the bright side" as to downplay the negative effects of a choice. The less you do this, the more you will be able to learn from your past experiences.
      </vert-slide>
      <vert-slide>
        # Dunning-Kruger effect

        [Dunning-Kruger effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)

        Overestimating, or underestimating, your abilities relative to others.

        <talk-img src="img/xkcd-the-bdlpswdks-effect.png" height="500"></talk-img>

        < I heard about the Dunning-Kruger effect long before I knew what it was. It's basically every Facebook comment thread. Anything you can put "armchair" before describes one aspect of this, which is when you overestimate your own abilities in relation to others. The other aspect of this is when you underestimate yourself in the same way, which is very similar to imposter syndrome.
      </vert-slide>
      <vert-slide>
        # Illusory truth effect

        [Illusory truth effect](https://en.wikipedia.org/wiki/Illusory_truth_effect)

        The tendency to believe information to be correct after repeated exposure.

        <talk-img src="img/xkcd-jet-fuel.png" height="500"></talk-img>

        < The last one I want to call out is the illusory truth effect because this is how misinformation spreads. It's very prevalent in contemporary politics, but also very much alive in our industry. You may have heard the expression: "the DOM is slow", or that it's "too bloated". This is a result of it being asserted many times without clear context around it.
      </vert-slide>
      <vert-slide>
        # Epidemic

        Nobody is safe!

        - Animals
        - Your boss
        - Thought leaders
        - Teachers and mentors ([curse of knowledge](https://en.wikipedia.org/wiki/Curse_of_knowledge))

        <talk-img src="img/xkcd-duty-calls.png" height="300"></talk-img>

        < The thing about bias is that nobody is immune to it. Your dog, you, your boss and that thought-leader you idolise; they're all subject to it. Even this talk!
        
        < The most objective people, who are extremely well-versed in a subject, can suffer from a bias that's called the curse of knowledge which is when a someone, communicating with others, unknowingly assumes that they have the background to understand the subject matter.
      </vert-slide>
      <vert-slide>
        # WTF

        > Are we at an amateur psychology conference??

        > &mdash; Maybe you, right now

        - Web components at Atlassian, or are they?
        - How can we be better

        < At this point, you might be asking what the heck this has to do with web components. That's a very good question, and it's one that I'm going to spend the rest of the talk addressing.

        < I'm first going to talk about our story of using web components at Atlassian and the eventual outcome, and the reasons for that outcome.

        < Then &mdash; and by no means am I a saint &mdash; I'll try and call out a few things working for me, that I think we all can try doing to be better people, at work in our programming communities and in the world.
      </vert-slide>
      <vert-slide>
        # My bias

        - &hearts;'s web components to the max
        - Uber vocal WC community member
        - Author of [SkateJS](https://github.com/skatejs/skatejs)
        - Uses React every day and also &hearts;'s it, but still prefers web components

        < This is probably a good time to reveal some of my biases, as it will help set the stage for the rest of the talk.

        < I totally dig web components. It's nice to see an essential piece of the platform finally come to fruition.

        < I'm also a very vocal member in the web component community and occasionally the W3C issues. I definitely spout subjectivity on a regular basis but it doesn't mean that I don't try to be objective!

        < I'm the author of SkateJS. For those of you who don't know what it that is, it's similar to React but built on top of Web Components. I urge you to check it out if you haven't already.

        < I also use React on a daily basis and really enjoy it. It's a great tool, and I've obtained an invaluable amount of knowledge from using it. I still have my reasons for preferring web components as a platform, though.

        < I think it's quite common for us to find something we like and stick with it. Using familiar tools helps make us efficient. That's not to say that if we would make the effort to broaden our experience that it wouldn't help us become better programmers, even if the result is that we stick with the same tools.
      </vert-slide>
      <vert-slide>
        # Web Components at Atlassian

        - Built Skate circa 2014
        - Lightly used WCs between 2014 and 2016
        - Unstable spec, lack of browser support, heavy slow polyfills made it hard
        - Mid-2016, new project, clean slate
        - Focus: dev speed + cross product components

        < I had originally written Skate in the early days of the web component spec, toward the beginning of 2014. It was in response to some spikes we were doing to try and find a better architecture to start moving our components to. Skate now to Skate in 2014 is black and white; worlds apart. Skate made progress, but we didn't make much progress in fully embracing web components or evangelising it as a team.

        < I've tried to figure out why we never made much progress, but it's hard to pinpoint what caused it. I often think it was due to [analysis paralysis](https://en.wikipedia.org/wiki/Analysis_paralysis) in the sheer amount of problems we had to solve, situations we had to account for and number of stakeholders the project had. The instability of the spec, lack of browser support, and the size and performance issues that plagued the v0 polyfills, compounded that problem.

        < About two years later, we were given a clean slate to work on a new project, similar to our old project, and to put our old project into maintenance mode. The goal was to build UI components to share across our product range, with more focused goals, and an emphasis on dev speed.

        < Along side this, React had been picking up a lot of steam internally. Most products were starting to use it in some way, shape or form. In parallel, Web Components were reaching spec stability and browsers began implementing the most important parts: custom elements and shadow DOM.
      </vert-slide>
      <vert-slide>
        # Web Components at Atlassian

        - Perfect time to move on Web Components
        - Cross-product, cross-framework
        - Leverages the platform
        - Skate is tiiiny (though polyfills are large, they are eventually removed)
        - No React version coupling

        < It was a pivotal point for us because we could push web components without being held back by our legacy product. It made a lot of sense due to spec stability and impending browser adoption.

        < On top of that, web components offer not only cross-product, but also cross-framework compatibility, due to Shadow DOM hiding the implenentation details from external mutations. And this is imperative for integrating with virtual DOM libraries. This was particularly important to our team because we wanted for anyone to be able to consume our components, not just the parts of products written in React. It was either that or force other parts to be built in React. That's not necessarily a bad thing, but possibly not the best use of time.

        < Being able to leverage the platform means several things. You get specs, native performance and all that built-in behaviour that you don't have to send down the wire to the user.

        < Another big thing for us was not having to move at the speed of the slowest product. Meaning, we'd probably end up having to support the lowest React version in our products while trying to maintian compatibility &mdash; or alinging versions &mdash; with other products.
      </vert-slide>
      <vert-slide>
        # Web Components at Atlassian

        A [decision matrix](https://en.wikipedia.org/wiki/Decision_matrix) is a method to systematically indentify, analyze, and rate the performance of relationships between sets of values and information.

        <talk-img src="img/decision-matrix.jpg" height="400"></talk-img>

        < Web Components seemed perfect on paper, but we had to justify why we thought they were the best choice for us.

        < We used a decision matrix to do this.

        < *read definition and go over the matrix*

        < We ended up doing a decision matrix for React vs Web Components, and then another one for SkateJS vs Polymer vs X-Tags. Web components won by a modest margin and Skate won, hands down.

        < It's here that you might be thinking, "Aren't you biased towards both of those?'"

        < Indeed I am. However, I was also the one who had the deepest knowledge of Web Components and the supporting libraries. Other people involved in the decision making process helped keep my bias in check by fact-checking information and asking some pretty tough questions along the way.
      </vert-slide>
      <vert-slide>
        # Web Components at Atlassian

        Six months later:

        - Already built 50+ web components
        - Some friction in getting Skate to 1.0
        - Spec changes caused breaking Skate releases
        - Minor investment, that went mostly as planned

        < Fast-forward a few months. We've built out around 40 web components all written with Skate. There was some learning barriers, but since Skate is a lot like React, it was easier to pick up for devs familiar with React than it would be with something else.

        < This was pre Skate 1.0 and we had anticipated some friction getting it to 1.0, and for the time investment to slow down sometime shortly after that. This part went mostly as expected. There was quite a bit of effort on my part in getting 1.0 across the line and a bit of effort from myself and a couple of other devs bringing it past that.

        < It went from 1.0 to 3.0 fairly quickly as there was some unanticipated changes in the specs and we decided that it'd be best to convey those changes through our versions, even though they might be unlikely to affect a consumer.
      </vert-slide>
      <vert-slide>
        # Web Components at Atlassian

        We didn't anticipate some things:

        - Still maintaining our own Shadow DOM polyfill
        - Polyfills unstable for longer than expected
        - Minor bugs when native custom elements released
        - Safari releasing a broken Shadow DOM implementation

        < I want to start off by saying that I'm really not trying to call anyone out. Browser and polyfill vendors are doing an amazing job at what they do, and I truly appreciate their contributions. Huge respect.

        < One big issue we were still facing is bugs in our own Shadow DOM polyfill that we were maintaining. We started this effor prior to Google building out their v1 polyfill because we needed a solution at the time and we had our reasons for not picking up the v0 polyfills. We had almost a thousand tests that were all passing but when you dropped them into a huge product with a lot of imperative DOM code, parts still broke.

        < We spent some time trying to fix these and decided that we'd try the official polyfills as Google had done a significant amount of work on them since we had started our own. It turns out they didn't improve the situation much, but were moving quicker than we could maintain ours, so we decided to use them instead.

        < Native custom elements posed a couple of trivial bugs with Skate but nothing major. We fixed them and moved on.

        < The biggest issue that we had was when Safari released their v1 Shadow DOM implementation. Our world broke. We had content, but it looked like someone threw in a CSS reset with Times New Roman as the base font. Everything worked in Chrome, and we were doint everything by the books, so what went wrong?

        < After a bit of debugging, it turned out that if you created and set the content of a style tag imperatively that the styles wouldn't recalc. This isn't an issue if you innerHTML the template to your shadow root, but we were using Incremental DOM &mdash; a virtual DOM library &mdash; to render our templates to our components, and underneath the hood it uses the imperative API to patch the DOM.

        < I want to emphasise the fact that an issue was found, and raised, while Safari was still in tech preview and it was still released to stable without a fix in sight until the next update to Mac OS. I get that things happen and sometimes issues slip through the cracks, but this ended up being the straw for us. We were floored; completely helpless.

        < What would have happend, if in another six months down the road, we were flying along in production and Firefox did the same thing. Even though it's a bug in Firefox, the customer is going to come knocking down our door, not Mozilla's. We had to pull the plug.
      </vert-slide>
      <vert-slide>
        # Dem feels

        <talk-img src="img/dem-feels.gif"></talk-img>

        < I was beside myself. I had poured my heart and soul into Skate and Web Components, and there was a lot of time invested by other people, but it just wasn't enough. There was nothing we could do. I had to look at this more objectively.
      </vert-slide>
      <vert-slide>
        # Web Components at Atlassian

        - Did <a href="https://en.wikipedia.org/wiki/Framing_effect_(psychology)">framing</a> affect either outcome?
        - Over time, new information, updated criteria
        - Decision matrices can provide a false sense of objectivity
        - Stability more important than before
        - Version coupling less important

        < Looking back, I've had to ask myself: were the outcomes of the matrices framed in a way to make either solution appear a better fit that they actually were?

        < I've talked to others about this and we feel Skate was still the best choice. It gave us fantastic developer ergonomics, and performance, in a really tiny package that exported a raw web component. Though I am undeniably biased, the decision was objectively informed by several parties.

        < Looking back on the Web Component decision is tricky. Over time, we acquired new information and the criteria changed slightly. All involved parties agree that we made the most objective decision possible at the time. However, when revisiting the rationale with new information and updated criteria, React won by a wider margin than web components the first time. So, what went wrong?

        < Decision matrices can provide a false sensitivity of objectivity. Weights around stability had become of utmost importance. Hindsight is 20 / 20. Looking back, it's obvous we should have pelanlised web components more for this, but we were confident that polyfills would be more stable and browser implementations further along. I'd say that confirmation bias played a big role in skewing this aspect of the matrix because we were dismissing evidence that could have helped us make a better informed decision.
        
        < The way we originally framed the criteria for library weight was biased in favour of web components because we anticipated version coupling to be an issue and you can't have more than one React on the page; web components don't care about this. However, we didn't have any hard evidence that version coupling would cause us any issues. We did have similar issues in the past with jQuery, but those seem to have surfaced because we weren't good about dropping support for older versions as it became prudent to do so. This being the case, we couldn't justify the heavy weighting in this category, so we updated them to assume version coupling, thus React could be deduped and only one would be on the page at any given time. If all products use React in a specific version range, then we would have less page weight than if we had used web components with a supporting library.
        
        < Additionally, even though Skate is only a few kilobytes in size, the polyfills would add a very significant amount of weight. And though, Chrome and Safari had both Custom Elements and Shadow DOM by this time, Safari still hadn't released a fix for the Shadow DOM bug. Firefox and Edge had started development, but we had anticipated they'd be further along.

        < As a side note: you could write vanilla components, but there's a strong argument against that due to the sheer amount of code and duplication you'd have to add to the platform. This is an entirely separate topic for another talk.
      </vert-slide>
      <vert-slide>
        # Black clouds

        - Low morale, motivation
        - Refactor all components to React
        - Team had limited React experience

        < If we could have a moment of bias, I think we all wanted web components to win; all evidence suggests that they're the right tool for the job and paving new ground with bleeding tech is fun and inspiring.

        < Pragmatism suggested otherwise and I think the objectivity weighed heavily on morale regardless of what is right long-term. It was palpable. But what's great about a well-formed team is they pick each other back up and dust each other off. You end up better off then before you fell.

        < I'm very lucky to work with such a diverse and intelligent bunch of people. I'm well and truly a better person because of them.
      </vert-slide>
      <vert-slide>
        # Silver linings

        Skate is a lot like React!
        
        - Already using JSX
        - Not using CSS polyfills
        - Using CSS in JS, so just remove `&lt;style /&gt;` from shadow roots
        - `&lt;slot /&gt;` -> `this.props.children`

        < Skate ended up being a godsend here.
        
        < Even though we didn't have to, we were already using JSX. This made using the existing component structure a breeze. And while some things ended up having to change a little, this made the transition simpler because we didn't need to move everything around.

        < We had thought about trying to use the Shady CSS polyfills just before revisiting the tech stack, but up until that point we were largely using the standard Webpack style loader and CSS modules. In a couple of components we were spiking CSS in JS solutions like [Glamor](https://github.com/threepointone/glamor) and [JSS](https://github.com/cssinjs/jss). Either way, refactoring styles mostly involved removing the `style` tag that we put into our shadow roots because we weren't using any shadow-specific CSS.

        < Though there's a bit more to them, React `children` are a lot like the `&lt;slot /&gt;` element in Shadow DOM. Refactoring here was mostly just renaming `&lt;slot /&gt;` to `this.props.children`.
      </vert-slide>
      <vert-slide>
        # WTF part deux!

        > So, you came to a web component conference to talk about React?

        > &mdash; Maybe you, right now

        < You might be wondering why I'm giving this talk at a web component conference, where you'd expect to see technical talks espousing the benefits of web components as opposed to the caveats and harships.

        < I'm such a web component fanboy it's not even funny, so you can put down the pitchforks. The reason I wanted to do this talk is that there's so much we can learn, and do better at, if we look at past experiences objectively and are empathetic to alternative points of view.

        < This is a more abstract lesson we can apply to most social ideologies, but let's look at it in the context of web components.
      </vert-slide>
      <vert-slide>
        # Past issues

        - Introduced in 2011; that's a pretty long time ago
        - Conflating Polymer and web components
        - Comparing low-level APIs to libraries
        - Divergent alternatives
        - Last minute spec churn
          - Lifecycle `*Callback` renaming
            - attached / detached
            - enteredView / leftView
            - inserted / removed
            - connected / disconencted
          - Other renames
            - `document.registerElement` to `customElements.define`
            - `createShadowRoot` to `attachShadow`

        < Web Components were introduced by Alex Russell at Fronteers Conference 2011 for the first time. That's roughly six years ago. In that time a lot has happened. Google released Polymer in 2014, later released 1.0 and are now pushing 2.0. React, Preact, Vue, Choo, Riot, Mithril and probably hundreds more, have all been released and are like web components, but not built on top of the standards. If I could take a guess as to why, I'd say it's close to the same reasons React eventually became the chosen platform for our components.

        < Another issue is that some seemed to conflate Polymer and Web Components. Rather than seeing it as a library built on top of the specs, some thought it was *the* web component implementation. This may have caused some to look the other direction if they didn't like the opinions that Polymer imposed. I don't think this isn't for lack of trying; they clearly explained this at several points in their docs, but there wasn't much else to choose from, and not everyone comprehensively reads docs.

        < One of the biggest reasons I feel web components lost steam is the amount of time it's taken for the specs to reach stability. There's many reasons for this, and I fully understand that some things need to be hashed out, but at the end of the day, we want to build stuff and developers are going to choose what makes them productive, regardless of whether or not it's web components. Personally, I don't care if it's `createShadowRoot()` or `attachShadow()`, I really just want to be able to use Shadow DOM.
        
        < Overall, a lot of these changes were necessary, and positive, but I feel the W3C working group for web components needs to take the community, and those who provide feedback, more seriously, and to also learn from what's happening around them in other communities. I fully empathise with the fact that lack of browser agreement in important issues has not helped this process. The lack of compromise on their part has possibly been one of the most impactful problems that has hamstrung web components. We need to try and look at the bigger picture as a whole.

        < As I've stated before, I'm not trying to pick on anyone, or any group, in particular. However, if we don't call these things out, how can we ever improve? Realising shortcomings isn't easy, and it's something that even the best of us struggle with, but we can only become better if we know what to improve on.
      </vert-slide>
      <vert-slide>
        # The future is bright

        - Cross-framework components
        - Longevity
        - Performance
        - Productivity

        < Though it's been a slog, we're almost there. The future is indeed bright and there's many benefits that we can, and should, count on.

        < "Framework agnostic UI components" has always been the elevator pitch but this is only scratching the surface. Instead of realying on Polymer or Skate to provide abstractions, what if you could use a Vue component inside of a React component just by writing HTML? Or vice-versa? With tree-shaking, size becomes less of an issue. If you build on top of the platform and embrace the constraints &mdash; which means "just write HTML" etc &mdash; this is entirely possible. The politics of this is more complicated, because it's harder to lock developers in to your framework as a platform, but we need to start realising that the web is more than just the number of stars you have on Github.

        < Longevity &mdash; For as much shade as I threw toward the spec earlier, it's probably the largest contributor to the web being the most democratic, popular, long-lived and stable platform that we have ever had the privilege to build on top of. And let's face it, we're pretty privileged if we can change lifecycle callback names four times.

        < Performance &mdash; When you register a custom element, you're handing off so many things that you'd have to do at the framework or library level. In doing this, your element lifecycle is closer to the metal and as a by-product, we don't have to reinvent that. Which leads me to my next point.

        < Productivity &mdash; If we're not reinventing the core component lifecycle and optimising things that the browser already does well, we can spend time on other things, like actually building components. We can even build abstractions &mdash; like Skate and Polymer &mdash; on top of the platform and feedback the relevant parts to the spec.
      </vert-slide>
      <vert-slide>
        # Amost there...

        ...but there's still lots of confusion

        - Styling
        - Integrating CSS frameworks ([info](https://github.com/skatejs/skatejs/issues/984))
        - Handling changes to children ([info](https://github.com/skatejs/skatejs/issues/995))
        - When to use shadow DOM, when not to
        - Forms inside of a shadow root ([issue](https://github.com/w3c/webcomponents/issues/187), [workaround](https://skatejs.gitbooks.io/skatejs/content/docs/recipes/form-behaviour-and-the-shadow-dom.html))

        < I just want to spend a few minutes touching on some points that still seem to hold quite a bit of mass confusion among those writing web components that have come up several times in the Skate issues and other places.

        < Developers still seem fairly confused in the best way to style components. A quesiton I've heard many ask is "isn't it going to be slow if I render one style tag for every component?".

        < There is no straightforward way to integrate existing CSS frameworks like Foundation or Bootstrap. The best solution I could find is to include the parts you need, but there's a lot of friction in doing that, and sometimes you end up including most of it anyways. The most robust method is to include the whole thing in every style tag. Going back to the previous question, isn't that bad?

        < Another issue I see a lot is when you try and build something like a custom select component and you have children that represent the custom options. Slots work great for projecting content, and there's the `slotchange` event, but that doesn't get fired for the children that are already there when the component is upgraded, and working out exactly what to do when it does change isn't exactly clear. The other side to this is if you have no slots &mdash; but still need to act on child content &mdash; how do you observe changes to that content? Many of us will immediately turn to mutation observers. Some are scarred from mutation events and will question if that's the right choice. Others won't even know how to do this at all.

        < One of the more common questions I get in Skate is how to turn off rendering to a shadow root, which can be for several reasons. One reason is for simpler styling because selectors become fair game, but legitimately, many seemed very concerned about accessibility and web crawlers indexing their content. I don't have a good answer for this, but one thing is for sure: for seamless integration with other frameworks that control child content of you element, you absolutely *must* hide your implementation details from them, so turning off Shadow DOM shouldn't be the answer we give them.

        < A shortcoming we've encountered is when building custom form elements. If you put a form element inside of a shadow root, the value never gets serialised when the parent form is submitted. There's proposals for solving this, but nothing concrete has been worked out yet. Luckily, there's workarounds, but it means rebuilding that behaviour.
      </vert-slide>
      <vert-slide>
        # Misinformation through rhetoric
        
        - My apples are better than your oranges
        - Inferior framing
        - Divides communities
        - http://www.backalleycoder.com/2016/08/26/demythstifying-web-components/

        < Many of the arguments I've seen against web components employs some form of pitting them against a farmework or library. Comparing a low-level API to several levels of abstraction is not constructive. Regardless of whether or not it was done intentionally to frame web components as inferior, we need to do a better job of educating people about web components.

        < I've seen several high-profile people in other framework communities spreading misinformation about Web Components. Many of these have been addressed in a great post that Daniel Buchner wrote, so I won't go into it, but it's necessary to point out that this is a struggle that web components has, and will continue to struggle with for some time, due to the lingering effects of uninformed and biased arguments.
      </vert-slide>
      <vert-slide>
        # The moral of the story?

        - Recognise your own bias
        - Stop throwing punches
        - Realise the bigger picture
        - Educate

        < Though it's impossible to do 100%, we need to try and remove our biases because it will help make decisions more objective and dicsussions more productive. Empathy is a very useful tool.

        < Despite the allegiances that we hold, we need to take a step back and focus on the bigger picture. It's not about being he winner of a popularity contest, but about making the web a better place for everyone.

        < And last, the best way to overcome the problems that our communities face, is through education and objective discussion.
        
        < **Let's solve problems *together*.**
      </vert-slide>
      <vert-slide>
        # About me

        Trey Shugart, Principal Dev @ Atlassian, creator of [SkateJS](https://github.com/skatejs/skatejs)

        - Github: https://github.com/treshugart
        - Twitter: https://twitter.com/treshugart (@treshugart)
        - Slides: https://github.com/treshugart/talks/packages/eternal-sunshine-of-the-biased-mind
        - Slides created using: https://github.com/skatejs/vert/blob/master/packages/deck

        < Thank you!
      </vert-slide>
    </vert-deck>
    <script src="../dist/talks.min.js"></script>
  </body>
</html>
